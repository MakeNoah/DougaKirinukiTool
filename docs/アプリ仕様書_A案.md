# 概要
本仕様書は、YouTubeの動画を自動で収集し、特定のキーワードに基づいて音声（動画）ファイルを抽出するアプリケーションの設計と実装に関するものである。アプリケーションは、YouTubeの動画URLリストまたはローカルの動画ファイルを入力として受け付け、文字起こし結果と動画音声を利用して特定のキーワードを含む音声（動画）ファイルを出力する機能を持つ。商業アプリケーションとしての品質を目指し、使いやすさと堅牢性を考慮した設計を行う。

# 1. アプリケーションの目的
youtubeの動画のurlリスト、特定のフォルダの動画ファイル群のいずれかを利用し、文字起こしなどの結果と動画音声を利用して特定のキーワードで抽出した音声（動画）ファイルを出力することを目的とする。

# 2. 使用するライブラリ（案）
アプリケーションの機能を実現するために、以下のライブラリの使用を検討する。具体的な採用ライブラリは、アーキテクチャ構成案の選択によって変動する可能性がある。

*   **YouTube動画ダウンロード:** yt-dlp
*   **動画・音声処理:** FFmpeg (またはそのラッパーライブラリ)
*   **文字起こし:** Whisper (ローカル実行可能な高精度モデル) またはクラウドAPI (Google Cloud Speech-to-Text, AWS Transcribeなど)
*   **自然言語処理（キーワード抽出）:** NLTK, spaCyなど
*   **データベース:** SQLite3 (Python標準ライブラリ)

# 3. アプリケーションの主要機能
本アプリケーションは、以下の主要機能を持つ。

*   **入力管理機能:**
    *   YouTube URLまたはローカルファイルパスの追加、編集、削除をUIから行う。
    *   入力された動画リストを一覧で表示する。
    *   入力データの永続化（SQLiteによる保存）。
*   **動画処理機能:**
    *   入力されたYouTube URLから動画ファイルをダウンロードする。
    *   ローカルの動画ファイルを読み込む。
    *   動画ファイルから音声データを抽出する。
*   **文字起こし機能:**
    *   YouTube動画の場合、可能な限り公式のトランスクリプトを取得し利用する。
    *   トランスクリプトがない場合やローカル動画の場合、抽出した音声データから文字起こしを実行する。
    *   文字起こし結果の表示、および必要に応じた編集・修正機能。
    *   特定の単語の認識精度向上を目的とした辞書機能（オプション）。
*   **キーワード抽出機能:**
    *   ユーザーが抽出したいキーワードをUIから入力・管理する。
    *   文字起こし結果とタイムスタンプ情報を利用し、指定されたキーワードが含まれる音声区間を特定する。
*   **出力機能:**
    *   特定された音声区間の音声データのみを抽出し、指定された音声フォーマット（mp3, wavなど）で出力する。
    *   特定された音声区間の動画データ（元の動画の該当部分を切り出し）を、指定された動画フォーマット（mp4など）で出力する。
    *   出力ファイルの保存先ディレクトリ、ファイル名の命名規則などを設定する機能。
*   **ユーザーインターフェース (UI):**
    *   直感的で操作しやすい画面設計。
    *   入力管理、キーワード設定、処理実行、結果表示、出力設定などの画面。
    *   動画処理や文字起こしなどの進捗状況をリアルタイムで表示する機能。
    *   エラー発生時の適切なユーザーへの通知と、問題解決のための情報提供。

# 4. アーキテクチャ構成案
アプリケーションのアーキテクチャについて、以下の2つの構成案を提案する。それぞれのメリット・デメリットを比較検討し、最終的な採用技術を決定する。

## 構成案1: Electron + Python
*   **概要:** UIにElectronを使用し、バックエンド処理にPythonを使用する構成。ElectronはWeb技術（HTML, CSS, JavaScript）でUIを構築でき、Pythonは動画処理や文字起こしに関する豊富なライブラリを利用できる。
*   **メリット:**
    *   Web開発の経験があればUI開発が比較的容易。
    *   Pythonの豊富なライブラリエコシステムを活用できるため、動画処理や文字起こし機能の実装がしやすい。
    *   開発コミュニティが大きく、情報が得やすい。
*   **デメリット:**
    *   アプリケーションの実行ファイルサイズが大きくなりやすい。
    *   他のフレームワークと比較してメモリ使用量が多い傾向がある。
    *   配布方法や環境構築に考慮が必要な場合がある。

## 構成案2: Tauri + Rust
*   **概要:** UIにTauriを使用し、バックエンド処理にRustを使用する構成。TauriはRustをバックエンドに使用し、軽量でパフォーマンスの高いデスクトップアプリケーションを構築できる。UIはWeb技術で構築可能。
*   **メリット:**
    *   Electronと比較してアプリケーションサイズが非常に小さく、リソース消費も少ない。
    *   Rustの高速な実行性能とメモリ安全性を活用できる。
    *   セキュリティが高いアプリケーションを構築しやすい。
*   **デメリット:**
    *   Rustの学習コストがかかる。
    *   Pythonと比較して、動画処理や文字起こしに特化したライブラリの選択肢が少ない場合がある（FFmpegなどをRustから呼び出す形になる）。
    *   開発コミュニティはElectronよりは小さい。

# 5. データベース設計（案）
アプリケーションのデータを管理するために、SQLiteを使用する。以下のテーブルを持つシンプルなスキーマを想定する。

*   **videos テーブル:**
    *   id (INTEGER PRIMARY KEY AUTOINCREMENT)
    *   source_type (TEXT - 'youtube' or 'local')
    *   source_path (TEXT - YouTube URL or local file path)
    *   title (TEXT - 動画タイトル)
    *   duration (INTEGER - 動画時間 秒)
    *   status (TEXT - 'pending', 'downloading', 'processing', 'completed', 'error' など)
    *   created_at (DATETIME)
    *   updated_at (DATETIME)

*   **transcripts テーブル:**
    *   id (INTEGER PRIMARY KEY AUTOINCREMENT)
    *   video_id (INTEGER - videosテーブルへの外部キー)
    *   text (TEXT - 文字起こし結果の全文)
    *   created_at (DATETIME)

*   **transcript_segments テーブル:**
    *   id (INTEGER PRIMARY KEY AUTOINCREMENT)
    *   transcript_id (INTEGER - transcriptsテーブルへの外部キー)
    *   start_time (REAL - セグメント開始時間 秒)
    *   end_time (REAL - セグメント終了時間 秒)
    *   text (TEXT - セグメントのテキスト)

*   **keywords テーブル:**
    *   id (INTEGER PRIMARY KEY AUTOINCREMENT)
    *   keyword (TEXT - 抽出対象のキーワード)
    *   created_at (DATETIME)

# 6. API設計
バックエンド処理とUI間の通信には、適切なAPI設計が必要となる。RESTful API、gRPC、またはそれぞれのフレームワークが提供するIPC（プロセス間通信）メカニズムなどを検討する。

*   **検討事項:**
    *   動画の追加、削除、一覧取得
    *   キーワードの追加、削除、一覧取得
    *   処理の開始、停止、一時停止
    *   処理進捗の取得
    *   文字起こし結果の取得、更新
    *   抽出結果（音声・動画ファイルのパスなど）の取得

これらのAPIエンドポイントやメッセージ形式について、実装時に詳細を定義する。
